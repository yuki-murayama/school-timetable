/**
 * 時間割生成サービス 単体テスト
 *
 * 目的: AI制約満足問題解決アルゴリズムの型安全時間割生成システムの完全テスト
 * 対象ファイル: src/backend/services/timetable-generation-service.ts
 * カバレッジ目標: 123分岐 100%
 *
 * テスト分類:
 * - TTGS-INIT: 初期化とコンストラクタ（10分岐）
 * - TTGS-VALID: バリデーションロジック（15分岐）
 * - TTGS-CONST: 制約条件処理（20分岐）
 * - TTGS-GEN: 時間割生成アルゴリズム（35分岐）
 * - TTGS-OPT: 最適化アルゴリズム（18分岐）
 * - TTGS-ASYNC: 非同期ジョブ管理（15分岐）
 * - TTGS-ERROR: エラーハンドリング（10分岐）
 */

import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'
import type { Classroom, EnhancedSchoolSettings, Subject, Teacher } from '@shared/schemas'
import { TypeSafeTimetableGenerationService } from './timetable-generation-service'

// ======================
// モックデータ定義
// ======================

const _mockSchoolSettings = {
  id: 'settings-1',
  grade1Classes: 4,
  grade2Classes: 3,
  grade3Classes: 3,
  grade4Classes: 0,
  grade5Classes: 0,
  grade6Classes: 0,
  dailyPeriods: 6,
  saturdayPeriods: 4,
  validation: {
    rules: [],
    constraints: {},
    qualityThresholds: {}
  },
  statistics: {
    metrics: {},
    reports: {}
  },
  total: 1
}

const mockTeachers: Teacher[] = [
  {
    id: 'teacher-1',
    name: '田中先生',
    grades: [1],
    subjects: ['math', 'science'],
    assignmentRestrictions: [],
    maxWeeklyHours: 20,
    preferredTimeSlots: [
      { dayOfWeek: '月曜' as const, periods: [1, 2, 3] },
      { dayOfWeek: '火曜' as const, periods: [1, 2] },
      { dayOfWeek: '水曜' as const, periods: [1, 2, 3, 4] },
      { dayOfWeek: '木曜' as const, periods: [1, 2] },
      { dayOfWeek: '金曜' as const, periods: [1, 2, 3] }
    ],
    unavailableSlots: [],
  },
  {
    id: 'teacher-2',
    name: '佐藤先生',
    grades: [2],
    subjects: ['english', 'social'],
    assignmentRestrictions: [],
    maxWeeklyHours: 18,
    preferredSchedule: {
      Monday: ['2', '3', '4'],
      Tuesday: ['1', '2', '3'],
      Wednesday: ['2', '3'],
      Thursday: ['1', '2', '3'],
      Friday: ['2', '3', '4'],
    },
    unavailableSlots: [{ day: 'Friday', period: '1' }],
    isClassTeacher: false,
  },
]

const mockSubjects: Subject[] = [
  {
    id: 'math',
    name: '数学',
    grades: [1, 2, 3],
    weeklyHours: {
      '1': 4,
      '2': 3,
      '3': 4
    },
    requiresSpecialClassroom: false,
    classroomType: 'general',
    color: '#ff0000',
    order: 1,
  },
  {
    id: 'english',
    name: '英語',
    grades: [1, 2, 3],
    weeklyHours: {
      '1': 3,
      '2': 4,
      '3': 4
    },
    requiresSpecialClassroom: true,
    classroomType: 'その他',
    color: '#0000ff',
    order: 2,
  },
]

const mockClassrooms: Classroom[] = [
  {
    id: 'room-1a',
    name: '1年A組教室',
    type: '普通教室',
    capacity: 35,
    assignedClass: '1-A',
    equipment: ['projector', 'whiteboard'],
  },
  {
    id: 'lab-1',
    name: '語学室1',
    type: 'その他',
    capacity: 30,
    equipment: ['audio_system', 'computers'],
  },
]

const mockGenerationRequest = {
  schoolId: 'test-school',
  academicYear: 2024,
  semester: 'first' as const,
  preferences: {
    prioritizeTeacherPreferences: true,
    allowOvertime: false,
    balanceWorkload: true,
    minimizeRoomChanges: true,
  },
  constraints: {
    maxConsecutiveSubjects: 2,
    breakBetweenSubjects: true,
    lunchBreakSlot: '4',
    specialEventSlots: [],
  },
}

// ======================
// モック関数定義
// ======================

const mockD1Database = {
  prepare: vi.fn().mockReturnValue({
    bind: vi.fn().mockReturnValue({
      first: vi.fn().mockResolvedValue(_mockSchoolSettings),
      all: vi.fn().mockResolvedValue({ 
        results: [
          ...mockTeachers,
          ...mockSubjects,
          ...mockClassrooms
        ],
        total: 10,
        count: 10
      }),
      run: vi.fn().mockResolvedValue({ success: true })
    }),
    first: vi.fn().mockResolvedValue({
      grade1Classes: 4,
      grade2Classes: 3,
      grade3Classes: 3,
      dailyPeriods: 6,
      saturdayPeriods: 4,
      total: 1
    }),
    all: vi.fn().mockResolvedValue({ 
      results: [
        ...mockTeachers,
        ...mockSubjects,
        ...mockClassrooms
      ] 
    }),
    run: vi.fn().mockResolvedValue({ success: true })
  })
}

const mockEnv = {
  DB: mockD1Database,
  TIMETABLE_GENERATION_QUEUE: {
    send: vi.fn(),
  },
}

// サービスインスタンス
let service: TypeSafeTimetableGenerationService

describe('TypeSafeTimetableGenerationService', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    // モックを再設定
    mockD1Database.prepare.mockReturnValue({
      bind: vi.fn().mockReturnValue({
        first: vi.fn().mockResolvedValue({
          grade1Classes: 4,
          grade2Classes: 3,
          grade3Classes: 3,
          dailyPeriods: 6,
          saturdayPeriods: 4,
          total: 1
        }),
        all: vi.fn().mockResolvedValue({ 
          results: [
            ...mockTeachers,
            ...mockSubjects,
            ...mockClassrooms
          ] 
        }),
        run: vi.fn().mockResolvedValue({ success: true })
      }),
      first: vi.fn().mockResolvedValue(_mockSchoolSettings),
      all: vi.fn().mockResolvedValue({ 
        results: [
          ...mockTeachers,
          ...mockSubjects,
          ...mockClassrooms
        ],
        total: 10,
        count: 10
      }),
      run: vi.fn().mockResolvedValue({ success: true })
    })
    service = new TypeSafeTimetableGenerationService(mockEnv.DB)
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  // ======================
  // TTGS-INIT: 初期化とコンストラクタ（10分岐）
  // ======================

  describe('初期化とコンストラクタ', () => {
    /**
     * TTGS-INIT-001: 正常なコンストラクタ初期化
     * 目的: サービスインスタンスの正常作成確認
     * 分岐カバレッジ: コンストラクタ成功分岐
     */
    it('TTGS-INIT-001: 正常なコンストラクタ初期化', () => {
      const newService = new TypeSafeTimetableGenerationService(mockEnv.DB)
      expect(newService).toBeInstanceOf(TypeSafeTimetableGenerationService)
      expect(newService).toBeDefined()
    })

    /**
     * TTGS-INIT-002: 環境変数不正
     * 目的: 不正な環境での初期化エラー確認
     * 分岐カバレッジ: 環境バリデーション失敗分岐
     */
    it('TTGS-INIT-002: 環境変数不正でエラー', () => {
      expect(() => new TypeSafeTimetableGenerationService(null as D1Database)).toThrow()
    })

    /**
     * TTGS-INIT-003: データベース接続確認
     * 目的: データベース接続の初期化確認
     * 分岐カバレッジ: DB接続初期化分岐
     */
    it('TTGS-INIT-003: データベース接続確認', () => {
      const newService = new TypeSafeTimetableGenerationService(mockEnv.DB)
      expect(newService).toBeDefined()
    })
  })

  // ======================
  // TTGS-VALID: バリデーションロジック（15分岐）
  // ======================

  describe('バリデーションロジック', () => {
    /**
     * TTGS-VALID-001: 時間割生成リクエスト正常バリデーション
     * 目的: 正常なリクエストデータのバリデーション確認
     * 分岐カバレッジ: リクエストバリデーション成功分岐
     */
    it('TTGS-VALID-001: 時間割生成リクエスト正常バリデーション', async () => {
      const result = await service.generateTimetableForClass(1, 'A')
      expect(result).toBeDefined()
      expect(result.success).toBeDefined()
    })

    /**
     * TTGS-VALID-002: 不正なschoolId
     * 目的: 無効なschoolIdでのバリデーション失敗確認
     * 分岐カバレッジ: schoolIdバリデーション失敗分岐
     */
    it('TTGS-VALID-002: 不正な学年でバリデーション失敗', async () => {
      try {
        await service.generateTimetableForClass(0, 'A') // 無効な学年
        expect.fail('エラーが投げられるべき')
      } catch (error) {
        expect(error).toBeDefined()
      }
    })

    /**
     * TTGS-VALID-003: 不正なacademicYear
     * 目的: 無効な学年でのバリデーション失敗確認
     * 分岐カバレッジ: academicYearバリデーション失敗分岐
     */
    it('TTGS-VALID-003: 不正なクラス名でバリデーション失敗', async () => {
      try {
        await service.generateTimetableForClass(1, '1') // 無効なクラス名（A-Zでない）
        expect.fail('エラーが投げられるべき')
      } catch (error) {
        expect(error).toBeDefined()
      }
    })

    /**
     * TTGS-VALID-004: 制約条件バリデーション成功
     * 目的: 制約条件の正常バリデーション確認
     * 分岐カバレッジ: 制約バリデーション成功分岐
     */
    it('TTGS-VALID-004: 制約条件バリデーション成功', async () => {
      const result = await service.validateConstraints(mockGenerationRequest.constraints)
      expect(result.isValid).toBe(true)
      expect(result.warnings).toHaveLength(0)
    })

    /**
     * TTGS-VALID-005: 無効な制約条件
     * 目的: 矛盾する制約条件でのバリデーション失敗確認
     * 分岐カバレッジ: 制約競合検出分岐
     */
    it('TTGS-VALID-005: 無効な制約条件でバリデーション失敗', async () => {
      const invalidConstraints = {
        ...mockGenerationRequest.constraints,
        maxConsecutiveSubjects: 0,
      }
      const result = await service.validateConstraints(invalidConstraints)
      expect(result.isValid).toBe(false)
      expect(result.errors).toContain('連続授業数は1以上である必要があります')
    })

    /**
     * TTGS-VALID-006: 教師データバリデーション
     * 目的: 教師データの整合性確認
     * 分岐カバレッジ: 教師データバリデーション分岐
     */
    it('TTGS-VALID-006: 教師データバリデーション', async () => {
      const result = await service.validateTeacherData(mockTeachers)
      expect(result.isValid).toBe(true)
      expect(result.conflicts).toHaveLength(0)
    })

    /**
     * TTGS-VALID-007: 教師スケジュール競合検出
     * 目的: 教師スケジュールの競合検出確認
     * 分岐カバレッジ: スケジュール競合検出分岐
     */
    it('TTGS-VALID-007: 教師スケジュール競合検出', async () => {
      const conflictingTeachers = [
        ...mockTeachers,
        {
          ...mockTeachers[0],
          id: 'teacher-conflict',
          assignedClass: '1-A', // 同じクラス担任
        },
      ]
      const result = await service.validateTeacherData(conflictingTeachers)
      expect(result.isValid).toBe(false)
      expect(result.conflicts).toContain('クラス担任が重複しています: 1-A')
    })
  })

  // ======================
  // TTGS-CONST: 制約条件処理（20分岐）
  // ======================

  describe('制約条件処理', () => {
    /**
     * TTGS-CONST-001: 教師制約条件適用
     * 目的: 教師の制約条件適用確認
     * 分岐カバレッジ: 教師制約適用分岐
     */
    it('TTGS-CONST-001: 教師制約条件適用', async () => {
      const constraints = await service.buildTeacherConstraints(mockTeachers[0])
      expect(constraints.maxHoursPerWeek).toBe(20)
      expect(constraints.unavailableSlots).toHaveLength(0)
      expect(constraints.preferredSlots).toContain('Monday-1')
    })

    /**
     * TTGS-CONST-002: 教科制約条件適用
     * 目的: 教科の制約条件適用確認
     * 分岐カバレッジ: 教科制約適用分岐
     */
    it('TTGS-CONST-002: 教科制約条件適用', async () => {
      const constraints = await service.buildSubjectConstraints(mockSubjects[0])
      expect(constraints.maxConsecutiveHours).toBe(2)
      expect(constraints.preferredTimeSlots).toContain('2')
      expect(constraints.avoidTimeSlots).toContain('1')
    })

    /**
     * TTGS-CONST-003: 教室制約条件適用
     * 目的: 教室の制約条件適用確認
     * 分岐カバレッジ: 教室制約適用分岐
     */
    it('TTGS-CONST-003: 教室制約条件適用', async () => {
      const constraints = await service.buildClassroomConstraints(mockClassrooms)
      expect(constraints.specialRooms).toContain('language_lab')
      expect(constraints.roomCapacities['room-1a']).toBe(35)
    })

    /**
     * TTGS-CONST-004: 制約競合解決
     * 目的: 制約条件の競合解決確認
     * 分岐カバレッジ: 制約競合解決分岐
     */
    it('TTGS-CONST-004: 制約競合解決', async () => {
      const conflictingConstraints = {
        teacherPrefers: ['Monday-1'],
        subjectAvoids: ['Monday-1'],
        roomUnavailable: [],
      }
      const resolved = await service.resolveConstraintConflicts(conflictingConstraints)
      expect(resolved.resolution).toBe('subject_priority')
      expect(resolved.appliedConstraints).not.toContain('Monday-1')
    })

    /**
     * TTGS-CONST-005: ハード制約条件チェック
     * 目的: 違反不可能な制約条件の確認
     * 分岐カバレッジ: ハード制約チェック分岐
     */
    it('TTGS-CONST-005: ハード制約条件チェック', async () => {
      const hardConstraints = {
        teacherUnavailable: ['Monday-1'],
        roomConflict: ['room-1a'],
        mandatorySubjects: ['math'],
      }
      const isValid = await service.validateHardConstraints(hardConstraints)
      expect(isValid).toBe(true)
    })

    /**
     * TTGS-CONST-006: ソフト制約条件最適化
     * 目的: 最適化可能な制約条件の処理確認
     * 分岐カバレッジ: ソフト制約最適化分岐
     */
    it('TTGS-CONST-006: ソフト制約条件最適化', async () => {
      const softConstraints = {
        teacherPreferences: ['morning_slots'],
        workloadBalance: true,
        minimizeRoomChanges: true,
      }
      const optimized = await service.optimizeSoftConstraints(softConstraints)
      expect(optimized.score).toBeGreaterThan(0)
      expect(optimized.appliedOptimizations).toContain('morning_preference')
    })
  })

  // ======================
  // TTGS-GEN: 時間割生成アルゴリズム（35分岐）
  // ======================

  describe('時間割生成アルゴリズム', () => {
    beforeEach(() => {
      mockD1Database.all.mockResolvedValue([])
      mockD1Database.first.mockResolvedValue(null)
      mockD1Database.run.mockResolvedValue({ success: true })
    })

    /**
     * TTGS-GEN-001: 基本時間割生成
     * 目的: 基本的な時間割生成アルゴリズムの確認
     * 分岐カバレッジ: 基本生成アルゴリズム分岐
     */
    it('TTGS-GEN-001: 基本時間割生成', async () => {
      mockD1Database.all
        .mockResolvedValueOnce(mockTeachers)
        .mockResolvedValueOnce(mockSubjects)
        .mockResolvedValueOnce(mockClassrooms)

      const result = await service.generateTimetableForClass(1, 'A')
      expect(result).toBeDefined()
      expect(result.success).toBeDefined()
    })

    /**
     * TTGS-GEN-002: 制約満足問題解決
     * 目的: CSP（制約満足問題）アルゴリズムの確認
     * 分岐カバレッジ: CSP解決分岐
     */
    it('TTGS-GEN-002: 制約満足問題解決', async () => {
      const cspProblem = {
        variables: ['slot1', 'slot2', 'slot3'],
        domains: {
          slot1: ['math', 'english'],
          slot2: ['science', 'social'],
          slot3: ['art', 'music'],
        },
        constraints: [
          { type: 'teacher_availability', slots: ['slot1', 'slot2'] },
          { type: 'room_conflict', slots: ['slot2', 'slot3'] },
        ],
      }

      const solution = await service.solveCSP(cspProblem)
      expect(solution.isSolvable).toBe(true)
      expect(solution.assignment).toBeDefined()
      expect(solution.satisfiedConstraints).toBeGreaterThan(0)
    })

    /**
     * TTGS-GEN-003: バックトラッキング実装
     * 目的: バックトラッキングアルゴリズムの確認
     * 分岐カバレッジ: バックトラッキング分岐
     */
    it('TTGS-GEN-003: バックトラッキング実装', async () => {
      const initialAssignment = new Map([
        ['slot1', 'math'],
        ['slot2', null],
        ['slot3', null],
      ])

      const result = await service.backtrackSearch(initialAssignment, [])
      expect(result.success).toBeDefined()
      if (result.success) {
        expect(result.finalAssignment.size).toBeGreaterThan(0)
      }
    })

    /**
     * TTGS-GEN-004: ヒューリスティック適用
     * 目的: 最小残余値ヒューリスティックの確認
     * 分岐カバレッジ: MRVヒューリスティック分岐
     */
    it('TTGS-GEN-004: ヒューリスティック適用', async () => {
      const variables = ['teacher1', 'teacher2', 'teacher3']
      const domains = {
        teacher1: ['monday-1', 'monday-2'],
        teacher2: ['monday-1'],
        teacher3: ['monday-1', 'monday-2', 'monday-3'],
      }

      const nextVariable = await service.selectVariableMRV(variables, domains)
      expect(nextVariable).toBe('teacher2') // 最小残余値
    })

    /**
     * TTGS-GEN-005: 制約伝播
     * 目的: 制約伝播アルゴリズムの確認
     * 分岐カバレッジ: 制約伝播分岐
     */
    it('TTGS-GEN-005: 制約伝播', async () => {
      const assignment = new Map([['slot1', 'teacher1']])
      const constraints = [{ type: 'no_double_booking', variables: ['slot1', 'slot2'] }]

      const propagated = await service.propagateConstraints(assignment, constraints)
      expect(propagated.reducedDomains).toBeDefined()
      expect(propagated.isConsistent).toBe(true)
    })

    /**
     * TTGS-GEN-006: 解なし検出
     * 目的: 解が存在しない場合の検出確認
     * 分岐カバレッジ: 解なし検出分岐
     */
    it('TTGS-GEN-006: 解なし検出', async () => {
      const impossibleProblem = {
        variables: ['slot1'],
        domains: { slot1: [] },
        constraints: [],
      }

      const result = await service.solveCSP(impossibleProblem)
      expect(result.isSolvable).toBe(false)
      expect(result.reason).toBe('empty_domain')
    })

    /**
     * TTGS-GEN-007: 部分解生成
     * 目的: 完全解が見つからない場合の部分解生成確認
     * 分岐カバレッジ: 部分解生成分岐
     */
    it('TTGS-GEN-007: 部分解生成', async () => {
      const difficultProblem = {
        variables: ['slot1', 'slot2', 'slot3'],
        domains: {
          slot1: ['teacher1'],
          slot2: ['teacher1'], // 競合
          slot3: ['teacher2'],
        },
        constraints: [{ type: 'no_double_booking', variables: ['slot1', 'slot2'] }],
      }

      const result = await service.solveCSP(difficultProblem, { allowPartialSolution: true })
      expect(result.isPartialSolution).toBe(true)
      expect(result.completeness).toBeLessThan(1.0)
    })

    /**
     * TTGS-GEN-008: 時間割品質評価
     * 目的: 生成された時間割の品質評価確認
     * 分岐カバレッジ: 品質評価分岐
     */
    it('TTGS-GEN-008: 時間割品質評価', async () => {
      const sampleTimetable = {
        'Monday-1': { teacher: 'teacher1', subject: 'math', room: 'room-1a' },
        'Monday-2': { teacher: 'teacher2', subject: 'english', room: 'lab-1' },
      }

      const quality = await service.evaluateTimetableQuality(sampleTimetable)
      expect(quality.overallScore).toBeGreaterThan(0)
      expect(quality.constraintSatisfaction).toBeDefined()
      expect(quality.teacherWorkloadBalance).toBeDefined()
    })
  })

  // ======================
  // TTGS-OPT: 最適化アルゴリズム（18分岐）
  // ======================

  describe('最適化アルゴリズム', () => {
    /**
     * TTGS-OPT-001: 局所探索最適化
     * 目的: 局所探索による最適化確認
     * 分岐カバレッジ: 局所探索分岐
     */
    it('TTGS-OPT-001: 局所探索最適化', async () => {
      const initialTimetable = {
        'Monday-1': { teacher: 'teacher1', subject: 'math', room: 'room-1a' },
        'Monday-2': { teacher: 'teacher2', subject: 'english', room: 'lab-1' },
      }

      const optimized = await service.optimizeLocalSearch(initialTimetable)
      expect(optimized.improved).toBe(true)
      expect(optimized.finalScore).toBeGreaterThanOrEqual(optimized.initialScore)
    })

    /**
     * TTGS-OPT-002: シミュレーテッドアニーリング
     * 目的: SA最適化アルゴリズムの確認
     * 分岐カバレッジ: SA最適化分岐
     */
    it('TTGS-OPT-002: シミュレーテッドアニーリング', async () => {
      const initialSolution = {
        timetable: {},
        score: 0.5,
      }

      const result = await service.simulatedAnnealing(initialSolution, {
        initialTemperature: 1000,
        coolingRate: 0.95,
        minTemperature: 1,
      })

      expect(result.bestSolution).toBeDefined()
      expect(result.iterations).toBeGreaterThan(0)
    })

    /**
     * TTGS-OPT-003: 遺伝的アルゴリズム
     * 目的: GA最適化の確認
     * 分岐カバレッジ: GA最適化分岐
     */
    it('TTGS-OPT-003: 遺伝的アルゴリズム', async () => {
      const population = [
        { genes: ['A', 'B', 'C'], fitness: 0.6 },
        { genes: ['B', 'A', 'C'], fitness: 0.7 },
        { genes: ['C', 'B', 'A'], fitness: 0.5 },
      ]

      const result = await service.geneticAlgorithm(population, {
        generations: 10,
        mutationRate: 0.1,
        crossoverRate: 0.8,
      })

      expect(result.bestIndividual).toBeDefined()
      expect(result.convergenceGeneration).toBeLessThanOrEqual(10)
    })

    /**
     * TTGS-OPT-004: 多目的最適化
     * 目的: 複数目的関数の最適化確認
     * 分岐カバレッジ: 多目的最適化分岐
     */
    it('TTGS-OPT-004: 多目的最適化', async () => {
      const objectives = [
        { name: 'teacher_satisfaction', weight: 0.4 },
        { name: 'room_utilization', weight: 0.3 },
        { name: 'schedule_balance', weight: 0.3 },
      ]

      const result = await service.multiObjectiveOptimization(objectives)
      expect(result.paretoFront).toBeDefined()
      expect(result.bestCompromise).toBeDefined()
    })

    /**
     * TTGS-OPT-005: 制約違反修復
     * 目的: 制約違反の自動修復確認
     * 分岐カバレッジ: 制約修復分岐
     */
    it('TTGS-OPT-005: 制約違反修復', async () => {
      const violatedTimetable = {
        'Monday-1': { teacher: 'teacher1', subject: 'math', room: 'room-1a' },
        'Monday-2': { teacher: 'teacher1', subject: 'english', room: 'room-1a' }, // 同一教師・教室の競合
      }

      const repaired = await service.repairConstraintViolations(violatedTimetable)
      expect(repaired.isValid).toBe(true)
      expect(repaired.repairs).toContain('teacher_conflict')
    })

    /**
     * TTGS-OPT-006: 近似解算出
     * 目的: 制限時間内での近似解算出確認
     * 分岐カバレッジ: 近似解分岐
     */
    it('TTGS-OPT-006: 近似解算出', async () => {
      const result = await service.findApproximateSolution(mockGenerationRequest, {
        timeLimit: 1000, // 1秒
        qualityThreshold: 0.8,
      })

      expect(result.solution).toBeDefined()
      expect(result.quality).toBeGreaterThan(0)
      expect(result.computationTime).toBeLessThan(1100)
    })
  })

  // ======================
  // TTGS-ASYNC: 非同期ジョブ管理（15分岐）
  // ======================

  describe('非同期ジョブ管理', () => {
    /**
     * TTGS-ASYNC-001: ジョブ生成
     * 目的: 非同期ジョブの生成確認
     * 分岐カバレッジ: ジョブ生成分岐
     */
    it('TTGS-ASYNC-001: ジョブ生成', async () => {
      const jobId = await service.createGenerationJob(mockGenerationRequest)
      expect(jobId).toMatch(/^job-[a-f0-9-]+$/)
      expect(mockEnv.TIMETABLE_GENERATION_QUEUE.send).toHaveBeenCalled()
    })

    /**
     * TTGS-ASYNC-002: ジョブ状態更新
     * 目的: ジョブ状態の更新確認
     * 分岐カバレッジ: 状態更新分岐
     */
    it('TTGS-ASYNC-002: ジョブ状態更新', async () => {
      const jobId = 'job-test-123'
      await service.updateJobStatus(jobId, 'processing', { progress: 50 })

      expect(mockD1Database.prepare).toHaveBeenCalledWith(
        expect.stringContaining('UPDATE generation_jobs')
      )
    })

    /**
     * TTGS-ASYNC-003: ジョブ進捗監視
     * 目的: ジョブ進捗の監視確認
     * 分岐カバレッジ: 進捗監視分岐
     */
    it('TTGS-ASYNC-003: ジョブ進捗監視', async () => {
      const jobId = 'job-test-123'
      mockD1Database.first.mockResolvedValue({
        id: jobId,
        status: 'processing',
        progress: 75,
        metadata: JSON.stringify({ stage: 'optimization' }),
      })

      const progress = await service.getJobProgress(jobId)
      expect(progress.status).toBe('processing')
      expect(progress.progress).toBe(75)
      expect(progress.stage).toBe('optimization')
    })

    /**
     * TTGS-ASYNC-004: ジョブ結果保存
     * 目的: 生成結果の保存確認
     * 分岐カバレッジ: 結果保存分岐
     */
    it('TTGS-ASYNC-004: ジョブ結果保存', async () => {
      const jobId = 'job-test-123'
      const result = {
        success: true,
        timetable: { 'Monday-1': { teacher: 'teacher1', subject: 'math' } },
        metadata: { quality: 0.85 },
      }

      await service.saveJobResult(jobId, result)
      expect(mockD1Database.prepare).toHaveBeenCalledWith(
        expect.stringContaining('UPDATE generation_jobs')
      )
    })

    /**
     * TTGS-ASYNC-005: ジョブタイムアウト処理
     * 目的: 長時間実行ジョブのタイムアウト処理確認
     * 分岐カバレッジ: タイムアウト処理分岐
     */
    it('TTGS-ASYNC-005: ジョブタイムアウト処理', async () => {
      const jobId = 'job-timeout-test'
      const result = await service.handleJobTimeout(jobId, 30000) // 30秒タイムアウト

      expect(result.timedOut).toBe(true)
      expect(result.finalStatus).toBe('timeout')
    })

    /**
     * TTGS-ASYNC-006: 並列ジョブ管理
     * 目的: 複数ジョブの並列実行管理確認
     * 分岐カバレッジ: 並列実行分岐
     */
    it('TTGS-ASYNC-006: 並列ジョブ管理', async () => {
      const jobs = ['job-1', 'job-2', 'job-3']
      const result = await service.manageConcurrentJobs(jobs, { maxConcurrency: 2 })

      expect(result.completed).toHaveLength(3)
      expect(result.maxConcurrentReached).toBe(2)
    })

    /**
     * TTGS-ASYNC-007: ジョブキャンセル
     * 目的: 実行中ジョブのキャンセル確認
     * 分岐カバレッジ: キャンセル処理分岐
     */
    it('TTGS-ASYNC-007: ジョブキャンセル', async () => {
      const jobId = 'job-cancel-test'
      const result = await service.cancelJob(jobId)

      expect(result.cancelled).toBe(true)
      expect(result.status).toBe('cancelled')
    })
  })

  // ======================
  // TTGS-ERROR: エラーハンドリング（10分岐）
  // ======================

  describe('エラーハンドリング', () => {
    /**
     * TTGS-ERROR-001: データベースエラー処理
     * 目的: DB接続エラーの処理確認
     * 分岐カバレッジ: DBエラー処理分岐
     */
    it('TTGS-ERROR-001: データベースエラー処理', async () => {
      mockD1Database.all.mockRejectedValue(new Error('Database connection failed'))

      try {
        const result = await service.generateTimetableForClass(1, 'A')
        expect(result).toBeDefined()
      } catch (error) {
        expect((error as Error).message).toContain('Database')
      }
    })

    /**
     * TTGS-ERROR-002: 制約違反エラー
     * 目的: 解決不可能な制約の処理確認
     * 分岐カバレッジ: 制約違反エラー分岐
     */
    it('TTGS-ERROR-002: 制約違反エラー', async () => {
      const impossibleRequest = {
        ...mockGenerationRequest,
        constraints: {
          ...mockGenerationRequest.constraints,
          maxConsecutiveSubjects: -1, // 不正な値
        },
      }

      try {
        const result = await service.generateTimetableForClass(1, 'A')
        expect(result).toBeDefined()
      } catch (error) {
        expect((error as Error).message).toContain('制約')
      }
    })

    /**
     * TTGS-ERROR-003: メモリ不足エラー
     * 目的: 大規模データでのメモリ不足処理確認
     * 分岐カバレッジ: メモリエラー処理分岐
     */
    it('TTGS-ERROR-003: メモリ不足エラー', async () => {
      // 大量のデータを模擬
      const largeDataRequest = {
        ...mockGenerationRequest,
        metadata: {
          expectedComplexity: 'extremely_high',
          estimatedMemoryUsage: '2GB',
        },
      }

      try {
        const result = await service.generateTimetableForClass(1, 'A')
        expect(result).toBeDefined()
      } catch (error) {
        expect((error as Error).message).toContain('メモリ')
      }
    })

    /**
     * TTGS-ERROR-004: タイムアウトエラー
     * 目的: 生成タイムアウトの処理確認
     * 分岐カバレッジ: タイムアウトエラー分岐
     */
    it('TTGS-ERROR-004: タイムアウトエラー', async () => {
      const timeoutRequest = {
        ...mockGenerationRequest,
        options: { timeout: 1 }, // 1msタイムアウト
      }

      try {
        const result = await service.generateTimetableForClass(1, 'A')
        expect(result).toBeDefined()
      } catch (error) {
        expect((error as Error).message).toContain('タイムアウト')
      }
    })

    /**
     * TTGS-ERROR-005: 入力データ不正エラー
     * 目的: 不正な入力データの処理確認
     * 分岐カバレッジ: 入力検証エラー分岐
     */
    it('TTGS-ERROR-005: 入力データ不正エラー', async () => {
      const invalidRequest = {
        schoolId: null,
        academicYear: 'invalid',
        semester: 'unknown',
      } as Record<string, unknown>

      try {
        const result = await service.generateTimetableForClass(-1, '')
        expect(result).toBeDefined()
      } catch (error) {
        expect((error as Error).message).toContain('入力データ')
      }
    })
  })
})
